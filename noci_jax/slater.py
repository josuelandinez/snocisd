# Copyright 2023 NOCI_Jax developers. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import numpy as np
from noci_jax.misc import math_helpers
import logging

def tvecs_to_rmats(tvecs, nvir, nocc, occ_mat=None):
    '''
    Transform Thouless vectors into rotation matrices.
    Args:
        tvecs: array, can be size (N, 2*nvir*nocc), (2*nvir*nocc) or (N, 2, nvir, nocc).
        nvir: int, number of virtual orbitals.
        nocc: int, number of occupied orbitals.
    Kwargs:
        occ_mat: the rotation matrices for the occupied orbitals.
    Returns:
        array of size (N, 2, nvir, nocc)
    '''

    vecs_all = tvecs.reshape(-1, nvir, nocc)
    nvecs = vecs_all.shape[0]
    if occ_mat is None:
        occ_mat = np.eye(nocc)
    Imats = np.tile(occ_mat, (nvecs)).T.reshape(nvecs, nocc, nocc) # 2 for spins
    rmats = np.concatenate([Imats, vecs_all], axis=1)
    rmats = rmats.reshape(-1, 2, nvir+nocc, nocc)
    return rmats

def add_tvec_hf(tmats):
    '''
    Add the Hartree-Fock Thouless matrices to the list of Thouless
    '''
    t0 = np.zeros_like(tmats[0])[None, :] # add another axis
    t_all = np.vstack([t0, tmats])
    return t_all

def r2u_dets(mats):
    ndim = mats.ndim
    mats_n = np.array([mats, mats])
    if ndim > 2: 
        mats_n = mats_n.transpose(1, 0, 2, 3)

    return mats_n

def metric_rmats(rmat1, rmat2):
    '''
    Evaluate the overlap between the two Slater determinants represented by rotation matrices.
    '''
    mat = np.einsum('sji, sjk -> sik', rmat1.conj(), rmat2)
    ovlp = np.prod(np.linalg.det(mat), axis=-1)
    return ovlp


def orthonormal_mos(tmats):
    '''
    Get the orthonormalization matrix given a Thouless rotation. 
    Args:
        tmat: 3D array or 4D array, the thouless rotation of size (nt, spin, nvir, nocc)
    Returns:
        3D array: full rotation matrices to generate the new set of MOs.
    '''
    tshape = tmats.shape
    if len(tshape) <= 2: # matrices
        nvir, nocc = tshape
        norb = nvir + nocc
        Iocc = np.eye(nocc)
        Ivir = np.eye(nvir)

        Mocc = np.linalg.inv(Iocc + tmats.T.conj()@tmats).T.conj()
        Mvir = np.linalg.inv(Ivir + tmats@tmats.T.conj()).T.conj()
        Uocc = np.linalg.cholesky(Mocc)
        Uvir = np.linalg.cholesky(Mvir)
        mat_on = np.zeros((norb, norb))
        mat_on[:nocc, :nocc] = Uocc 
        mat_on[nocc:, :nocc] = tmats@Uocc 
        mat_on[:nocc, nocc:] = -tmats.conj().T@Uvir 
        mat_on[nocc:, nocc:] =  Uvir

    else: # more than one matrices
        Nt = np.prod(tshape[:-2])
        nvir, nocc = tshape[-2:]
        norb = nocc + nvir
        Iocc = np.eye(nocc)
        Ivir = np.eye(nvir)
        ts = tmats.reshape(Nt, nvir, nocc)

        Mocc = np.tile(Iocc, Nt).T.reshape(Nt, nocc, nocc)\
            + np.moveaxis(ts, -2, -1).conj()@ts
        Mvir = np.tile(Ivir, Nt).T.reshape(Nt, nvir, nvir)\
            + ts@np.moveaxis(ts, -2, -1).conj()

        Uocc = np.linalg.cholesky(Mocc)
        Uocc = np.moveaxis(np.linalg.inv(Uocc), -2, -1).conj()
        Uvir = np.linalg.cholesky(Mvir)
        Uvir = np.moveaxis(np.linalg.inv(Uvir), -2, -1).conj()

        mat_on = np.zeros((Nt, norb, norb))
        mat_on[:, :nocc, :nocc] = Uocc 
        mat_on[:, nocc:, :nocc] = ts@Uocc
        mat_on[:, :nocc, nocc:] = -np.moveaxis(ts, -2, -1).conj()@Uvir 
        mat_on[:, nocc:, nocc:] = Uvir 
        
    return mat_on.reshape(*list(tmats.shape[:-2]), norb, norb)


def rotate_rmats(rmats, U):
    '''
    Rotate the rmats based on Unitary matrix U.
    args:
        rmats: (nr, s, norb, nocc) array
        U: (s, norb, norb) array
    Returns:
        UR for each R
    '''
    return np.einsum('sij, nsjk -> nsik', U, rmats)


def noci_energy(rmats, mo_coeff, h1e, h2e, return_mats=False, lc_coeffs=None, e_nuc=0.0):
    '''
    NOCI energy from the determinants generated by rmats. 
    Solving generalized eigenvalue problem.
    Returns:
        float
    '''

    if return_mats:
        return noci_matrices(rmats, mo_coeff, h1e, h2e)

    if lc_coeffs is not None:
        return noci_energy_lc(rmats, mo_coeff, h1e, h2e, lc_coeffs, e_nuc)

    # first calculate metric and thus overlap
    metrics_all = np.einsum('nsji, msjk -> nmsik', rmats.conj(), rmats)
    smat = np.prod(np.linalg.det(metrics_all), axis=-1)

    try:
        ndim = mo_coeff.ndim 
    except:
        ndim = 3
        mo_coeff = np.asarray(mo_coeff)
    if ndim > 2:
        sdets = np.einsum("sij, nsjk -> nsik", mo_coeff, rmats)
    else:
        sdets = np.einsum("ij, nsjk -> nsik", mo_coeff, rmats)
    # transition density matrices
    inv_metrics = np.linalg.inv(metrics_all)
    trdms = np.einsum("msij, nmsjk, nslk -> nmsil", sdets, inv_metrics, sdets.conj())

    # transition hamiltonian
    E1 = np.einsum("ij, nmsji -> nm", h1e, trdms)
    J = np.einsum("ijkl, nmslk -> nmij", h2e, trdms)
    E2J = np.einsum("nmij, nmsji -> nm", J, trdms)
    K = np.einsum("ijkl, nmsjk -> nmsil", h2e, trdms)
    E2K = np.einsum("nmsij, nmsji ->nm", K, trdms)

    E2 = E2J - E2K

    hmat = (E1 + 0.5*E2) * smat

    energy = solve_lc_coeffs(hmat, smat, return_vec=False)
    return energy + e_nuc


def noci_energy_lc(rmats, mo_coeff, h1e, h2e, lc_coeffs, e_nuc=0.0):
    '''
    Given the linear combination coefficients, get the energy.
    '''
    # first calculate metric and thus overlap
    metrics_all = np.einsum('nsji, msjk -> nmsik', rmats.conj(), rmats)
    smat = np.prod(np.linalg.det(metrics_all), axis=-1)

    # transition density matrices
    try:
        ndim = mo_coeff.ndim 
    except:
        ndim = 3
        mo_coeff = np.asarray(mo_coeff)
    if ndim > 2:
        sdets = np.einsum("sij, nsjk -> nsik", mo_coeff, rmats)
    else:
        sdets = np.einsum("ij, nsjk -> nsik", mo_coeff, rmats)

    trdms = np.einsum("msij, nmsjk, nslk -> nmsil", sdets, np.linalg.inv(metrics_all), sdets.conj())
    sdets = None
    metrics_all = None
    
    # E1 = np.einsum("")
    # transition hamiltonian
    E1 = np.einsum("ij, nmsji -> nm", h1e, trdms)
    J = np.einsum("ijkl, nmslk -> nmij", h2e, trdms)
    J = np.einsum("nmij, nmsji -> nm", J, trdms)
    K = np.einsum("ilkj, nmslk -> nmsij", h2e, trdms)
    K = np.einsum("nmsij, nmsji ->nm", K, trdms)
    E2 = J - K
    # E2 = E2J - E2K
    trdms = None
    hmat = (E1 + 0.5*E2) * smat
    h = lc_coeffs.T.conj().dot(hmat).dot(lc_coeffs)
    s = lc_coeffs.T.conj().dot(smat).dot(lc_coeffs)
    energy = (h / s)

    return energy + e_nuc


def noci_matrices(rmats, mo_coeff, h1e, h2e):
    # first calculate metric and thus overlap
    metrics_all = np.einsum('nsji, msjk -> nmsik', rmats.conj(), rmats)
    smat = np.prod(np.linalg.det(metrics_all), axis=-1)

    try:
        ndim = mo_coeff.ndim 
    except:
        ndim = 3
        mo_coeff = np.asarray(mo_coeff)
    if ndim > 2:
        sdets = np.einsum("sij, nsjk -> nsik", mo_coeff, rmats)
    else:
        sdets = np.einsum("ij, nsjk -> nsik", mo_coeff, rmats)

    # transition density matrices
    inv_metrics = np.linalg.inv(metrics_all)
    trdms = np.einsum("msij, nmsjk, nslk -> nmsil", sdets, inv_metrics, sdets.conj())

    # transition hamiltonian
    E1 = np.einsum("ij, nmsji -> nm", h1e, trdms)
    J = np.einsum("ijkl, nmslk -> nmij", h2e, trdms)
    E2J = np.einsum("nmij, nmsji -> nm", J, trdms)
    K = np.einsum("ijkl, nmsjk -> nmsil", h2e, trdms)
    E2K = np.einsum("nmsij, nmsji ->nm", K, trdms)
    E2 = E2J - E2K
    hmat = (E1 + 0.5*E2) * smat
    return hmat, smat


def solve_lc_coeffs(hmat, smat, return_vec=False):
    '''
    Solve the eigenvalue problem Hc = ESc. 
    
    Returns:
        double, ground state energy
        if return_vec:
            1D array, linear combination coefficient
    '''
    energy, c = math_helpers.generalized_eigh(hmat, smat)
    if return_vec:
        return energy, c
    else:
        return energy
    

def make_rdm1(rmats, mo_coeff, lc_coeff):
    '''
    Make rdm1 of NOCI in the AO basis for UHF.
    Return: array of size (2, N, N)
    '''
    # first calculate metric and thus overlap
    metrics_all = np.einsum('nsji, msjk -> nmsik', rmats.conj(), rmats)
    smat = np.prod(np.linalg.det(metrics_all), axis=-1)

    try:
        ndim = mo_coeff.ndim 
    except:
        ndim = 3
        mo_coeff = np.asarray(mo_coeff)
    if ndim > 2:
        sdets = np.einsum("sij, nsjk -> nsik", mo_coeff, rmats)
    else:
        sdets = np.einsum("ij, nsjk -> nsik", mo_coeff, rmats)
    # transition density matrices
    inv_metrics = np.linalg.inv(metrics_all)
    trdms = np.einsum("msij, nmsjk, nslk -> nmsil", sdets, inv_metrics, sdets.conj())
    trdms = np.einsum("nmsij, nm -> nmsij", trdms, smat)

    top = np.einsum("n, m, nmsij -> sij", lc_coeff.conj(), lc_coeff, trdms) 
    bot = np.einsum("n, m, nm ->", lc_coeff.conj(), lc_coeff, smat)
    return top/bot


def make_rdm12(rmats, mo_coeff, lc_coeff):
    '''
    Make 2RDM given an NOCI.
    Return: (p,q,r,s) = <a^dag_p a_q a^dag_r a_s>
    Spin orders: [uuuu, uudd, dddd]
    dduu can be evaluated by transposing uudd: uudd.transpose(2,3,0,1) 
    '''
    metrics_all = np.einsum('nsji, msjk -> nmsik', rmats.conj(), rmats)
    smat = np.prod(np.linalg.det(metrics_all), axis=-1)

    mo_coeff = np.asarray(mo_coeff)
    ndim = mo_coeff.ndim 
    if ndim > 2:
        sdets = np.einsum("sij, nsjk -> nsik", mo_coeff, rmats)
    else:
        sdets = np.einsum("ij, nsjk -> nsik", mo_coeff, rmats)

    # transition density matrices
    inv_metrics = np.linalg.inv(metrics_all)
    trdms = np.einsum("msij, nmsjk, nslk -> nmsil", sdets, inv_metrics, sdets.conj())
    dm1s = np.einsum("nmsij, nm -> nmsij", trdms, smat)
    dm1_u = trdms[:, :, 0]
    dm1_d = trdms[:, :, 1]
    dm2s_uu = np.einsum("nmij, nmkl -> nmijkl", dm1_u, dm1_u) \
             - np.einsum("nmil, nmkj -> nmijkl", dm1_u, dm1_u)
    dm2s_dd = np.einsum("nmij, nmkl -> nmijkl", dm1_d, dm1_d) \
             - np.einsum("nmil, nmkj -> nmijkl", dm1_d, dm1_d)
    dm2s_ud = np.einsum("nmij, nmkl -> nmijkl", dm1_u, dm1_d)
    # dm2s_du = np.einsum("nmij, nmkl -> nmijkl", dm1_d, dm1_u)
    # dm2s = np.array([dm2s_uu, dm2s_ud, dm2s_du, dm2s_dd])
    dm2s = np.array([dm2s_uu, dm2s_ud, dm2s_dd])
    dm2s = np.einsum("snmijkl, nm -> snmijkl", dm2s, smat)
    dm1s = np.einsum("n, m, nmsij -> sij", lc_coeff.conj(), lc_coeff, dm1s) 
    dm2s = np.einsum("n, m, snmijkl -> sijkl", lc_coeff.conj(), lc_coeff, dm2s)

    phi_norm = np.einsum("n, m, nm ->", lc_coeff.conj(), lc_coeff, smat)
    return dm1s/phi_norm, dm2s/phi_norm


def make_rdm12_diag(rmats, mo_coeff, lc_coeff):
    '''
    Return the diagonal of rdm1 and rdm2_ud.
    Returns:
        rdm1: a list of two 1D arrays.
        rdm2: 2D array of order uudd.
    '''
    metrics_all = np.einsum('nsji, msjk -> nmsik', rmats.conj(), rmats)
    smat = np.prod(np.linalg.det(metrics_all), axis=-1)
    mo_coeff = np.asarray(mo_coeff)
    ndim = mo_coeff.ndim 
    if ndim > 2:
        sdets = np.einsum("sij, nsjk -> nsik", mo_coeff, rmats)
    else:
        sdets = np.einsum("ij, nsjk -> nsik", mo_coeff, rmats)
    # transition density matrices
    inv_metrics = np.linalg.inv(metrics_all)
    trdms_diag = np.einsum("msij, nmsjk, nsik -> nmsi", sdets, inv_metrics, sdets.conj())
    dm1s_diag = np.einsum("nmsi, nm -> nmsi", trdms_diag, smat)
    dm1_u = trdms_diag[:, :, 0]
    dm1_d = trdms_diag[:, :, 1]

    dm2s_ud = np.einsum("nmi, nmj -> nmij", dm1_u, dm1_d)
    dm2s_ud = np.einsum("nmij, nm -> nmij", dm2s_ud, smat)

    dm1s_diag = np.einsum("n, m, nmsi -> si", lc_coeff.conj(), lc_coeff, dm1s_diag) 
    dm2s_ud = np.einsum("n, m, nmij -> ij", lc_coeff.conj(), lc_coeff, dm2s_ud)

    phi_norm = np.einsum("n, m, nm ->", lc_coeff.conj(), lc_coeff, smat)
    return dm1s_diag/phi_norm, dm2s_ud/phi_norm

def get_smat(rmats):
    '''
    Get the overlap matrix of the given determinants.
    '''
    metrics = np.einsum('nsji, msjk -> nmsik', rmats.conj(), rmats)
    smat = np.prod(np.linalg.det(metrics), axis=-1)   
    return smat

def expand_hs(hmat0, smat0, rmats_n, rmats_fix, h1e, h2e, mo_coeff):
    '''
    Expand the H matrix and S matrix
    | (fix, fix)   (fix, n)|
    | (n, fix)     (n, n)  |
    (fix, fix) is given by h_n and s_n
    we evaluate (n, fix) and (n, n)  
    '''
    n_fix = len(rmats_fix)
    n_new = len(rmats_n)
    n_tot = n_fix + n_new
    
    hm = np.zeros((n_tot, n_tot))
    sm = np.zeros((n_tot, n_tot))
    hm[:n_fix, :n_fix] = hmat0
    sm[:n_fix, :n_fix] = smat0


    # generate hmat and smat for the lower left block and upper right block
    h_left, s_left = _gen_hsmat(rmats_n, rmats_fix, mo_coeff, h1e, h2e)
    hm[n_fix:, :n_fix] = h_left
    hm[:n_fix, n_fix:] = h_left.T.conj()
    sm[n_fix:, :n_fix] = s_left
    sm[:n_fix, n_fix:] = s_left.T.conj()

    # generate hmat and smat for the lower diagonal block
    h_new, s_new = noci_energy(rmats_n, mo_coeff, h1e, h2e, return_mats=True)
    hm[n_fix:, n_fix:] = h_new
    sm[n_fix:, n_fix:] = s_new

    return hm, sm



def expand_smat(smat_fix, rmats_fix, rmats_new):
    '''
    Given the previous smat from rmats_fix, add the rows and columns from
    rmats_new.
    '''
    n_fix = len(rmats_fix)
    n_new = len(rmats_new)
    n_tot = n_fix + n_new
    metrics_mix = np.einsum('nsji, msjk -> nmsik', rmats_fix.conj(), rmats_new)
    smat_left = np.prod(np.linalg.det(metrics_mix), axis=-1)
    metrics_new = np.einsum('nsji, msjk -> nmsik', rmats_new.conj(), rmats_new)
    smat_new = np.prod(np.linalg.det(metrics_new), axis=-1)

    smat = np.zeros((n_tot, n_tot))
    smat[:n_fix, :n_fix] = smat_fix
    smat[:n_fix, n_fix:] = smat_left
    smat[n_fix:, :n_fix] = smat_left.conj().T
    smat[n_fix:, n_fix:] = smat_new

    return smat
    
    
def _gen_hsmat(rmats1, rmats2, mo_coeff, h1e, h2e):
    '''
    Return the matrices of the Hamiltonian and overlap matrix with
    respect to two sets of rotation matrices.
    '''

    # first calculate metric and thus overlap
    metrics_all = np.einsum('nsji, msjk -> nmsik', rmats1.conj(), rmats2)
    smat = np.prod(np.linalg.det(metrics_all), axis=-1)

    # transition density matrices
    inv_metrics = np.linalg.inv(metrics_all)
    sdets1 = np.einsum("sij, nsjk -> nsik", mo_coeff, rmats1)
    sdets2 = np.einsum("sij, nsjk -> nsik", mo_coeff, rmats2)
    trdms = np.einsum("msij, nmsjk, nslk -> nmsil", sdets2, inv_metrics, sdets1.conj())

    # transition hamiltonian
    E1 = np.einsum("ij, nmsji -> nm", h1e, trdms)
    J = np.einsum("ijkl, nmslk -> nmij", h2e, trdms)
    E2J = np.einsum("nmij, nmsji -> nm", J, trdms)
    K = np.einsum("ijkl, nmsjk -> nmsil", h2e, trdms)
    E2K = np.einsum("nmsij, nmsji ->nm", K, trdms)

    E2 = E2J - E2K
    hmat = (E1 + 0.5*E2) * smat
   
    return hmat, smat

def half_spin(rmats, U=None, mo_coeffs=None, tol=1e-5):
    '''
    Swap the spin-up and spin-down MOs for the determinant.
    '''
    if U is None:
        Ca = mo_coeffs[0]
        Cb = mo_coeffs[1]
        len_C = Ca.shape[0]

        # check if RHF 
        diff = Ca - Cb 
        if np.linalg.norm(diff)/len_C**2 < tol:
            logging.warning("Two spins are degenerate.")
            return None
        else:
            U = np.linalg.inv(Ca) @ Cb

    # evaluate the rotation matrix
    rmats_n = np.zeros_like(rmats)
    rmats_n[:, 0] = np.einsum('ij, njk -> nik', U, rmats[:, 1])
    rmats_n[:, 1] = np.einsum('ji, njk -> nik', U.conj(), rmats[:, 0])
    return rmats_n


if __name__ == "__main__":
    print("Main function:\n")
