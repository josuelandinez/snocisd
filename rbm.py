# Restricted Boltzmann machine for NOCI
# NOTE Only works for hidden variables = 0, 1
# Naming systems:
# params: parameters of RBM, usually with the shape (nparam, lparam)
# tvecs: the vector form of the Thouless matrices (flattened)
# tmats: Thouless matrices
# rmats: rotation matrices of the MO coefficients (adding I on top of tmats)
# sdets: MO coefficients of the Slater determinants

import numpy as np
import noci
import itertools
import jax.numpy as jnp
from jax.config import config
config.update("jax_enable_x64", True)


def expand_vecs(params, coeffs):
    '''
    Expand the RBM vectors to all configurations.
    Args:
        params: 2D array, RBM vectors of size (nparam, lparam)
        coeffs: expanded from hiddens
    Returns:
        2D array: expanded Thouless vectors of size (nparam**nhidden, lparam).
    '''
    tvecs = jnp.dot(coeffs, params)
    return tvecs

def add_vec(param0, tvecs):
    '''
    Given an RBM vector and the list of expanded Thouless vectors,
    return all new Thouless rotations generated by adding param0.
    Returns:
        The new set of vectors added to the old ones.
    NOTE: only for hiddens = [0, 1]
    '''
    tvecs_n = jnp.asarray(tvecs) + param0
    return tvecs_n


def tvecs_to_rmats(tvecs, nvir, nocc):

    vecs_all = tvecs.reshape(-1, nvir, nocc)
    nvecs = vecs_all.shape[0]
    I = jnp.eye(nocc)
    Imats = jnp.tile(I, (nvecs)).T.reshape(nvecs, nocc, nocc) # 2 for spins
    rmats = jnp.concatenate([Imats, vecs_all], axis=1)
    rmats = rmats.reshape(-1, 2, nvir+nocc, nocc)
    return rmats


def params_to_rmats(vecs, nvir, nocc, coeffs):

    vecs_all = jnp.dot(coeffs, vecs)
    vecs_all = vecs_all.reshape(-1, nvir, nocc)
    nvecs = vecs_all.shape[0]
    I = jnp.eye(nocc)
    Imats = jnp.tile(I, (nvecs)).T.reshape(nvecs, nocc, nocc) # 2 for spins
    rmats = jnp.concatenate([Imats, vecs_all], axis=1)
    rmats = rmats.reshape(-1, 2, nvir+nocc, nocc)
    return rmats

def hiddens_to_coeffs(hiddens, nvecs):
    '''
    Generate all possible combinations of the nvecs of hidden variables.
    Args:
        nvecs: number of RBM vectors
        hiddens: values of hidden variables
    Returns:
        2D array.
    '''
    coeffs = []
    for iter in itertools.product(hiddens, repeat=nvecs):
        sum_coeff = np.asarray(iter)
        coeffs.append(sum_coeff)
      
    coeffs = np.array(coeffs)
    return coeffs


def rbm_energy(rmats, mo_coeff, h1e, h2e, return_mats=False):
    '''
    NOCI energy from the determinants generated by rmats.
    Returns:
        float
    '''

    # first calculate metric and thus overlap
    metrics_all = jnp.einsum('nsji, msjk -> nmsik', rmats.conj(), rmats)
    smat = jnp.prod(jnp.linalg.det(metrics_all), axis=-1)

    # transition density matrices
    inv_metrics = jnp.linalg.inv(metrics_all)
    sdets = jnp.einsum("sij, nsjk -> nsik", mo_coeff, rmats)
    trdms = jnp.einsum("msij, nmsjk, nslk -> nmsil", sdets, inv_metrics, sdets.conj())

    # transition hamiltonian
    E1 = jnp.einsum("ij, nmsji -> nm", h1e, trdms)
    J = jnp.einsum("ijkl, nmslk -> nmij", h2e, trdms)
    E2J = jnp.einsum("nmij, nmsji -> nm", J, trdms)
    K = jnp.einsum("ijkl, nmsjk -> nmsil", h2e, trdms)
    E2K = jnp.einsum("nmsij, nmsji ->nm", K, trdms)

    E2 = E2J - E2K

    hmat = (E1 + 0.5*E2) * smat
    if return_mats:
        return hmat, smat
    else:
        energy = noci.solve_lc_coeffs(hmat, smat, return_vec=False)
        return energy


def gen_hmat(rmats1, rmats2, mo_coeff, h1e, h2e):
    '''
    NOCI energy from the determinants generated by rmats.
    Returns:
        float
    '''

    # first calculate metric and thus overlap
    metrics_all = jnp.einsum('nsji, msjk -> nmsik', rmats1.conj(), rmats2)
    smat = jnp.prod(jnp.linalg.det(metrics_all), axis=-1)

    # transition density matrices
    inv_metrics = jnp.linalg.inv(metrics_all)
    sdets1 = jnp.einsum("sij, nsjk -> nsik", mo_coeff, rmats1)
    sdets2 = jnp.einsum("sij, nsjk -> nsik", mo_coeff, rmats2)
    trdms = jnp.einsum("msij, nmsjk, nslk -> nmsil", sdets2, inv_metrics, sdets1.conj())

    # transition hamiltonian
    E1 = jnp.einsum("ij, nmsji -> nm", h1e, trdms)
    J = jnp.einsum("ijkl, nmslk -> nmij", h2e, trdms)
    E2J = jnp.einsum("nmij, nmsji -> nm", J, trdms)
    K = jnp.einsum("ijkl, nmsjk -> nmsil", h2e, trdms)
    E2K = jnp.einsum("nmsij, nmsji ->nm", K, trdms)

    E2 = E2J - E2K

    hmat = (E1 + 0.5*E2) * smat
   
    return hmat, smat

def solve_lc_coeffs(hmat, smat, return_vec=False):
    '''
    Solve the eigenvalue problem Hc = ESc. 
    Using scipy function, 4x times faster.
    Before: First solve S^-1/2 H S^-1/2 -> v, then c = S^-1/2 v
    Args:
        hmat: 2D numpy array of size (n**d, n**d)
        smat: 2D numpy array of size (n**d, n**d)
    Kwargs:
        return_vec: whether to return the LC coefficients.
    Returns:
        double, ground state energy
        A 1D numpy array of size (n**d,), linear combination coefficient

    '''
    e, v = generalized_eigh(hmat, smat)

    energy = e[0]
    c = v[:, 0]

    if return_vec:
        return energy, c
    else:
        return energy
    
def generalized_eigh(A, B):
    L = jnp.linalg.cholesky(B)
    L_inv = jnp.linalg.inv(L)
    A_redo = L_inv.dot(A).dot(L_inv.T)
    return jnp.linalg.eigh(A_redo)

# def metrics_all(rmats):
#     '''
#     Evaluate the metrics among all rotation matrices.
#     Args:
#         rmats: array of size (N, 2, norb, nocc)
#     returns:
#         array of size (N, N, 2, nocc, nocc)
#     '''
#     return jnp.einsum('nsji, msjk -> nmsik', rmats.conj(), rmats)

# def overlap_all(metrics):
#     '''
#     Args:
#         metrics: array of size (N, N, 2, nocc, nocc)
#     Returns:
#         array of size (N, N)
#     TODO test
#     '''
#     ovlp = jnp.linalg.det(metrics)
#     ovlp = jnp.prod(ovlp, axis=-1)
#     return ovlp

# def inverse_metrics(metrics):
#     '''
#     Args:
#         metrics: array of size (N, N, 2, nocc, nocc)
#     Returns:
#         array of size (N, N, 2, nocc, nocc)
#     '''
#     return jnp.linalg.inv(metrics)

# def gen_sdets(mo_coeff, rmats):
#     '''
#     Generate the molecular orbital representations of determinants.
#     Args:
#         mo_coeff: array of size (2, norb, norb)
#         rmats: array of size (N, 2, norb, nocc)
#     Returns:
#         sdets: array of size (N, 2, norb, nocc)
#     TODO test
#     '''
#     return np.einsum("sij, nsjk -> nsik", mo_coeff, rmats)

# def trans_density_matrices(sdets, inv_metrics):
#     '''
#     Evalute the transition density matrices.
#     Args:
#         sdets: array of size (N, 2, norb, nocc).
#         inv_metrics: inverse of the overlap metric, array of size (N, N, 2, nocc, nocc).
#     Returns:
#         array of size (N, N, 2, norb, norb).
#     TODO test
#     '''
#     return jnp.einsum("msij, nmsjk, nslk -> nmsil", sdets, inv_metrics, sdets.conj())
    

# def gen_energies(h1e, h2e, trdms):
#     '''
#     Evaluate the energies.
#     Args:
#         h1e: array of size (norb, norb)
#         h2e: array of size (norb, norb, norb, norb)
#         trdms: array of size (N, N, 2, norb, norb)
#     Returns:
#         array of size (N, N), energies
#     '''
#     E1 = jnp.einsum("ij, nmsji -> nm", h1e, trdms)

#     J = jnp.einsum("ijkl, nmslk -> nmij", h2e, trdms)
#     E2J = jnp.einsum("nmij, nmsji -> nm", J, trdms)
#     K = jnp.einsum("ijkl, nmsjk -> nmsil", h2e, trdms)
#     E2K = jnp.einsum("nmsij, nmsji ->nm", K, trdms)

#     E2 = E2J - E2K

#     E = E1 + 0.5*E2

#     return E



# def rbm_energy_nograd(rmats, mo_coeff, h1e, h2e, ao_ovlp=None):

#     # TODO rewrite this as a giant einsum

#     nt = len(rmats)

#     hmat = jnp.zeros((nt, nt))
#     smat = jnp.zeros((nt, nt))

#     for i in range(nt):
#         for j in range(i+1):
#             sdet1 = slater.rotation(mo_coeff, rmats[i])
#             sdet2 = slater.rotation(mo_coeff, rmats[j])
#             dm, ovlp = slater.make_trans_rdm1(sdet1, sdet2, ao_ovlp=ao_ovlp, return_ovlp=True)
#             jk = slater.get_jk(h2e, dm)
#             hval1 = jnp.einsum('ij, nji -> ', h1e, dm)
#             hval2 = jnp.einsum('nij, nji -> ', jk, dm)
#             hval = (hval1 + 0.5 * hval2) * ovlp
#             hmat = hmat.at[i, j].set(hval)
#             hmat = hmat.at[j, i].set(hval.conj()) 
#             smat = smat.at[i, j].set(ovlp)
#             smat = smat.at[j, i].set(ovlp.conj())

#     energy = noci.solve_lc_coeffs(hmat, smat, return_vec=False)
#     return energy

if __name__ == "__main__":
    print("Main function:\n")
