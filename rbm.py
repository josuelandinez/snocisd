# Restricted Boltzmann machine for NOCI
# NOTE Only works for hidden variables = 0, 1
# Naming systems:
# params: parameters of RBM, usually with the shape (nparam, lparam)
# tvecs: the vector form of the Thouless matrices (flattened)
# tmats: Thouless matrices
# rmats: rotation matrices of the MO coefficients (adding I on top of tmats)
# sdets: MO coefficients of the Slater determinants

import numpy as np
import itertools
import jax.numpy as jnp
from jax.config import config
config.update("jax_enable_x64", True)


def expand_vecs(params, coeffs):
    '''
    Expand the RBM vectors to all configurations.
    Args:
        params: 2D array, RBM vectors of size (nparam, lparam)
        coeffs: expanded from hiddens
    Returns:
        2D array: expanded Thouless vectors of size (nparam**nhidden, lparam).
    '''
    tvecs = jnp.dot(coeffs, params)
    return tvecs

def add_vec(param0, tvecs):
    '''
    Given an RBM vector and the list of expanded Thouless vectors,
    return all new Thouless rotations generated by adding param0.
    Returns:
        The new set of vectors added to the old ones.
    NOTE: only for hiddens = [0, 1]
    '''
    tvecs_n = jnp.asarray(tvecs) + param0
    return tvecs_n


def tvecs_to_rmats(tvecs, nvir, nocc):

    vecs_all = tvecs.reshape(-1, nvir, nocc)
    nvecs = vecs_all.shape[0]
    I = jnp.eye(nocc)
    Imats = jnp.tile(I, (nvecs)).T.reshape(nvecs, nocc, nocc) # 2 for spins
    rmats = jnp.concatenate([Imats, vecs_all], axis=1)
    rmats = rmats.reshape(-1, 2, nvir+nocc, nocc)
    return rmats


def params_to_rmats(vecs, nvir, nocc, coeffs):

    vecs_all = jnp.dot(coeffs, vecs)
    vecs_all = vecs_all.reshape(-1, nvir, nocc)
    nvecs = vecs_all.shape[0]
    I = jnp.eye(nocc)
    Imats = jnp.tile(I, (nvecs)).T.reshape(nvecs, nocc, nocc) # 2 for spins
    rmats = jnp.concatenate([Imats, vecs_all], axis=1)
    rmats = rmats.reshape(-1, 2, nvir+nocc, nocc)
    return rmats

def hiddens_to_coeffs_general(hiddens, nvecs, order=None):
    '''
    Generate all possible combinations of the nvecs of hidden variables.
    Args:
        nvecs: number of RBM vectors
        hiddens: values of hidden variables
    Returns:
        2D array.
    '''
    coeffs = []
    for iter in itertools.product(hiddens, repeat=nvecs):
        sum_coeff = np.asarray(iter)
        coeffs.append(sum_coeff)
      
    coeffs = np.array(coeffs)
    return coeffs

def hiddens_to_coeffs(hiddens, nvecs, order=1):
    import scipy 

    truc = 0
    for i in range(order+1):
        truc += scipy.special.comb(nvecs, i)
    truc = int(truc)
    mat = np.array(np.indices(nvecs * (2,))).reshape(nvecs, -1)
    res = mat[:, np.argsort(mat.sum(0)[::-1], kind='mergesort')].T[::-1]
    return res[:truc]

def gen_thouless_random(nocc, nvir, max_nt):

    tmats = []
    for i in range(max_nt):
        t = np.random.rand(2, nvir, nocc)
        #t = np.random.normal(size=tshape)
        tmats.append(t)

    return np.asarray(tmats)

def gen_thouless_singles(nocc, nvir, max_nt=None, zmax=10, zmin=0.1):
    '''
    Generate rotations for near singly excited state for spinless systems.
    Input:
        nocc: number of occupied orbitals.
        nvir: number of virtual orbitals.
    Kwargs:
        max_nrot: maximum number of matrices to generate.
    Returns:
        A list of unnormalized Thouless parameters.
    '''

    if max_nt is None:
        max_nt = nvir * nocc

    # pick the excitations closest to the Fermi level    
    sqrt_nt = int(np.sqrt(max_nt)) + 1
    if nocc < nvir:
        if nocc < sqrt_nt: 
            d_occ = nocc 
            d_vir = nvir  
        else:
            d_occ = sqrt_nt 
            d_vir = sqrt_nt
    else:
        if nvir < sqrt_nt:
            d_occ = nocc 
            d_vir = nvir 
        else:
            d_occ = sqrt_nt 
            d_vir = sqrt_nt

    tmats = []
    t0 = np.zeros((nvir, nocc))
    k = 0
    for i in range(d_occ): # occupied
        for j in range(d_vir): # virtual
            if k == max_nt:
                break
            tm = np.ones((nvir, nocc)) * zmin 
            tm[j, nocc-i-1] = zmax
            tmats.append(np.array([tm, t0]))
            tmats.append(np.array([t0, tm]))
            k += 1
    tmats = np.asarray(tmats)
    return tmats


def gen_thouless_doubles(nocc, nvir, max_nt=None, zmax=10, zmin=0.1):
    '''
    Generate rotations for near doubly excited state for spinless systems.
    Since (i -> a, j -> b) and (j -> a, i -> b) corresponds to the same determinant,
    we do not allow cross excitation, i.e., for (i -> a, j -> b), i < j and a < b.

    '''
    if max_nt is None:
        max_nt = int(nvir*(nvir-1)/2) * int(nocc*(nocc-1)/2)
    max_nt = min(max_nt, int(nvir*(nvir-1)/2) * int(nocc*(nocc-1)/2))

    tmats = []
    k = 0
    t0 = np.zeros((nvir, nocc))
    for i in range(nocc-1): # top e occ
        for j in range(i+1, nocc): # bot e occ
            for a in range(1, nvir): # top e vir
                for b in range(a): # bot e occ
                    if k == max_nt:
                        break
                    tm = np.ones((nvir, nocc)) * zmin 
                    tm[a, nocc-i-1] = zmax
                    tm[b, nocc-j-1] = zmax # HOMO electron is further excited
                    tmats.append([tm, t0])
                    tmats.append([t0, tm])
                    k += 1
    tmats = np.asarray(tmats)
    return tmats


def rbm_energy(rmats, mo_coeff, h1e, h2e, return_mats=False, lc_coeffs=None):
    '''
    NOCI energy from the determinants generated by rmats.
    Returns:
        float
    '''

    # first calculate metric and thus overlap
    metrics_all = jnp.einsum('nsji, msjk -> nmsik', rmats.conj(), rmats)
    smat = jnp.prod(jnp.linalg.det(metrics_all), axis=-1)

    # transition density matrices
    inv_metrics = jnp.linalg.inv(metrics_all)
    sdets = jnp.einsum("sij, nsjk -> nsik", mo_coeff, rmats)
    trdms = jnp.einsum("msij, nmsjk, nslk -> nmsil", sdets, inv_metrics, sdets.conj())

    # transition hamiltonian
    E1 = jnp.einsum("ij, nmsji -> nm", h1e, trdms)
    J = jnp.einsum("ijkl, nmslk -> nmij", h2e, trdms)
    E2J = jnp.einsum("nmij, nmsji -> nm", J, trdms)
    K = jnp.einsum("ijkl, nmsjk -> nmsil", h2e, trdms)
    E2K = jnp.einsum("nmsij, nmsji ->nm", K, trdms)

    E2 = E2J - E2K

    hmat = (E1 + 0.5*E2) * smat

    if return_mats:
        return hmat, smat
    else:
        if lc_coeffs is None:
            energy = solve_lc_coeffs(hmat, smat, return_vec=False)
        else:
            h = lc_coeffs.T.conj().dot(hmat).dot(lc_coeffs)
            s = lc_coeffs.T.conj().dot(smat).dot(lc_coeffs)
            energy = h / s
            
        return energy


def gen_hmat(rmats1, rmats2, mo_coeff, h1e, h2e):
    '''
    NOCI energy from the determinants generated by rmats.
    Returns:
        float
    '''

    # first calculate metric and thus overlap
    metrics_all = jnp.einsum('nsji, msjk -> nmsik', rmats1.conj(), rmats2)
    smat = jnp.prod(jnp.linalg.det(metrics_all), axis=-1)

    # transition density matrices
    inv_metrics = jnp.linalg.inv(metrics_all)
    sdets1 = jnp.einsum("sij, nsjk -> nsik", mo_coeff, rmats1)
    sdets2 = jnp.einsum("sij, nsjk -> nsik", mo_coeff, rmats2)
    trdms = jnp.einsum("msij, nmsjk, nslk -> nmsil", sdets2, inv_metrics, sdets1.conj())

    # transition hamiltonian
    E1 = jnp.einsum("ij, nmsji -> nm", h1e, trdms)
    J = jnp.einsum("ijkl, nmslk -> nmij", h2e, trdms)
    E2J = jnp.einsum("nmij, nmsji -> nm", J, trdms)
    K = jnp.einsum("ijkl, nmsjk -> nmsil", h2e, trdms)
    E2K = jnp.einsum("nmsij, nmsji ->nm", K, trdms)

    E2 = E2J - E2K

    hmat = (E1 + 0.5*E2) * smat
   
    return hmat, smat

def solve_lc_coeffs(hmat, smat, return_vec=False):
    '''
    Solve the eigenvalue problem Hc = ESc. 
    Using scipy function, 4x times faster.
    Before: First solve S^-1/2 H S^-1/2 -> v, then c = S^-1/2 v
    Args:
        hmat: 2D numpy array of size (n**d, n**d)
        smat: 2D numpy array of size (n**d, n**d)
    Kwargs:
        return_vec: whether to return the LC coefficients.
    Returns:
        double, ground state energy
        A 1D numpy array of size (n**d,), linear combination coefficient

    '''
    energy, c = generalized_eigh(hmat, smat)

    if return_vec:
        return energy, c
    else:
        return energy
    
def generalized_eigh(A, B):
    L = jnp.linalg.cholesky(B)
    L_inv = jnp.linalg.inv(L)
    A_redo = L_inv.dot(A).dot(L_inv.T)
    e, v = jnp.linalg.eigh(A_redo)
    e0 = e[0]
    v0 = v[:, 0]
    c0 = L_inv.T.dot(v0) # rotate back 

    return e0, c0

def _expand_hs(hmat0, smat0, rmats_n, rmats_fix, h1e, h2e, mo_coeff):
    '''
    Expand the H matrix and S matrix
    | (fix, fix)   (fix, n)|
    | (n, fix)     (n, n)  |
    (fix, fix) is given by h_n and s_n
    we evaluate (n, fix) and (n, n)  
    '''
    n_fix = len(rmats_fix)
    n_new = len(rmats_n)
    n_tot = n_fix + n_new
    
    hm = jnp.zeros((n_tot, n_tot))
    sm = jnp.zeros((n_tot, n_tot))
    hm = hm.at[:n_fix, :n_fix].set(hmat0)
    sm = sm.at[:n_fix, :n_fix].set(smat0)


    # generate hmat and smat for the lower left block and upper right block
    h_new, s_new = gen_hmat(rmats_n, rmats_fix, mo_coeff, h1e, h2e)
    hm = hm.at[n_fix:, :n_fix].set(h_new)
    hm = hm.at[:n_fix, n_fix:].set(h_new.T.conj())
    sm = sm.at[n_fix:, :n_fix].set(s_new)
    sm = sm.at[:n_fix, n_fix:].set(s_new.T.conj())

    # generate hmat and smat for the lower diagonal block
    h_new, s_new = rbm_energy(rmats_n, mo_coeff, h1e, h2e, return_mats=True)
    hm = hm.at[n_fix:, n_fix:].set(h_new)
    sm = sm.at[n_fix:, n_fix:].set(s_new)

    return hm, sm


if __name__ == "__main__":
    print("Main function:\n")
