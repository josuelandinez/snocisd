# Restricted Boltzmann machine for NOCI
# NOTE Only works for hidden variables = 0, 1
# Naming systems:
# params: parameters of RBM, usually with the shape (nparam, lparam)
# tvecs: the vector form of the Thouless matrices (flattened)
# tmats: Thouless matrices
# rmats: rotation matrices of the MO coefficients (adding I on top of tmats)
# sdets: MO coefficients of the Slater determinants

import numpy as np
import slater, noci
import itertools
import jax.numpy as jnp



def expand_vecs(params, hiddens=[0,1]):
    '''
    Expand the RBM vectors with respect to hiddens.
    Args:
        params: 2D array, RBM vectors of size (nparam, lparam)
    Kwargs:
        hiddens: list, hidden variables of RBM
    Returns:
        2D array: expanded Thouless vectors of size (nparam**nhidden, lparam).
    '''
    nparam = len(params)
    if nparam == 0:
        return []
    params = np.asarray(params)
    tvecs = []

    for iter in itertools.product(hiddens, repeat=nparam):
        sum_coeff = np.asarray(iter)
        t = np.dot(sum_coeff, params)
        tvecs.append(t)

    return tvecs


def add_vec(param0, tvecs):
    '''
    Given an RBM vector and the list of expanded Thouless vectors,
    return all new Thouless rotations generated by adding param0.
    Returns:
        The new set of vectors added to the old ones.
    NOTE: only for hiddens = [0, 1]
    '''
    tvecs_n = jnp.asarray(tvecs) + param0
    return tvecs_n

def tvecs_to_rotations(tvecs, tshape, normalize=True):
    '''
    Turn a vector to a rotation matrix.
    '''
    lt = len(tvecs)
    nvir, nocc = tshape
    rmats = []
    for i in range(lt):
        t = tvecs[i].reshape(2, nvir, nocc)
        r = slater.thouless_to_rotation(t) # put the identity operator on top
        if normalize:
            r = slater.normalize_rotmat(r)
        rmats.append(r)
    rmats = jnp.array(rmats)
    return rmats


def params_to_rmats(vecs, nvir, nocc, coeffs, normalize=False):

    vecs_all = jnp.dot(coeffs, vecs)
    vecs_all = vecs_all.reshape(-1, nvir, nocc)
    nvecs = vecs_all.shape[0]
    I = jnp.eye(nocc)
    Imats = jnp.tile(I, (nvecs)).T.reshape(nvecs, nocc, nocc) # 2 for spins
    rmats = jnp.concatenate([Imats, vecs_all], axis=1)
    rmats = rmats.reshape(-1, 2, nvir+nocc, nocc)
    return rmats

def hiddens_to_coeffs(hiddens, nvecs):
    '''
    Generate all possible combinations of the nvecs of hidden variables.
    Args:
        nvecs: number of RBM vectors
        hiddens: values of hidden variables
    Returns:
        2D array.
    '''
    coeffs = []
    for iter in itertools.product(hiddens, repeat=nvecs):
        sum_coeff = np.asarray(iter)
        coeffs.append(sum_coeff)
      
    coeffs = np.array(coeffs)
   
    return coeffs


def rbm_energy_nograd(rmats, mo_coeff, h1e, h2e, ao_ovlp=None):

    # TODO rewrite this as a giant einsum

    nt = len(rmats)

    hmat = jnp.zeros((nt, nt))
    smat = jnp.zeros((nt, nt))

    for i in range(nt):
        for j in range(i+1):
            sdet1 = slater.rotation(mo_coeff, rmats[i])
            sdet2 = slater.rotation(mo_coeff, rmats[j])
            dm, ovlp = slater.make_trans_rdm1(sdet1, sdet2, ao_ovlp=ao_ovlp, return_ovlp=True)
            jk = slater.get_jk(h2e, dm)
            hval1 = jnp.einsum('ij, nji -> ', h1e, dm)
            hval2 = jnp.einsum('nij, nji -> ', jk, dm)
            hval = (hval1 + 0.5 * hval2) * ovlp
            hmat = hmat.at[i, j].set(hval)
            hmat = hmat.at[j, i].set(hval.conj()) 
            smat = smat.at[i, j].set(ovlp)
            smat = smat.at[j, i].set(ovlp.conj())

    energy = noci.solve_lc_coeffs(hmat, smat, return_vec=False)
    return energy

if __name__ == "__main__":
    print("Main function:\n")
